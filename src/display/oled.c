#include "oled.h"

#include <stdio.h>
#include <string.h>

#include "app_config.h"
#include "i2c_ll.h"

#include "hardware/structs/i2c.h"
#include "pico/stdlib.h"

static i2c_hw_t *const oled_i2c = i2c0_hw;
static uint8_t g_buf[OLED_W * OLED_H / 8];

// 5x7 font (ASCII 32-126)
static const uint8_t font5x7[95][5] = {
    {0x00,0x00,0x00,0x00,0x00}, {0x00,0x00,0x5f,0x00,0x00},
    {0x00,0x07,0x00,0x07,0x00}, {0x14,0x7f,0x14,0x7f,0x14},
    {0x24,0x2a,0x7f,0x2a,0x12}, {0x23,0x13,0x08,0x64,0x62},
    {0x36,0x49,0x55,0x22,0x50}, {0x00,0x05,0x03,0x00,0x00},
    {0x00,0x1c,0x22,0x41,0x00}, {0x00,0x41,0x22,0x1c,0x00},
    {0x14,0x08,0x3e,0x08,0x14}, {0x08,0x08,0x3e,0x08,0x08},
    {0x00,0x50,0x30,0x00,0x00}, {0x08,0x08,0x08,0x08,0x08},
    {0x00,0x60,0x60,0x00,0x00}, {0x20,0x10,0x08,0x04,0x02},
    {0x3e,0x51,0x49,0x45,0x3e}, {0x00,0x42,0x7f,0x40,0x00},
    {0x42,0x61,0x51,0x49,0x46}, {0x21,0x41,0x45,0x4b,0x31},
    {0x18,0x14,0x12,0x7f,0x10}, {0x27,0x45,0x45,0x45,0x39},
    {0x3c,0x4a,0x49,0x49,0x30}, {0x01,0x71,0x09,0x05,0x03},
    {0x36,0x49,0x49,0x49,0x36}, {0x06,0x49,0x49,0x29,0x1e},
    {0x00,0x36,0x36,0x00,0x00}, {0x00,0x56,0x36,0x00,0x00},
    {0x08,0x14,0x22,0x41,0x00}, {0x14,0x14,0x14,0x14,0x14},
    {0x00,0x41,0x22,0x14,0x08}, {0x02,0x01,0x51,0x09,0x06},
    {0x32,0x49,0x79,0x41,0x3e}, {0x7e,0x11,0x11,0x11,0x7e},
    {0x7f,0x49,0x49,0x49,0x36}, {0x3e,0x41,0x41,0x41,0x22},
    {0x7f,0x41,0x41,0x22,0x1c}, {0x7f,0x49,0x49,0x49,0x41},
    {0x7f,0x09,0x09,0x09,0x01}, {0x3e,0x41,0x49,0x49,0x7a},
    {0x7f,0x08,0x08,0x08,0x7f}, {0x00,0x41,0x7f,0x41,0x00},
    {0x20,0x40,0x41,0x3f,0x01}, {0x7f,0x08,0x14,0x22,0x41},
    {0x7f,0x40,0x40,0x40,0x40}, {0x7f,0x02,0x0c,0x02,0x7f},
    {0x7f,0x04,0x08,0x10,0x7f}, {0x3e,0x41,0x41,0x41,0x3e},
    {0x7f,0x09,0x09,0x09,0x06}, {0x3e,0x41,0x51,0x21,0x5e},
    {0x7f,0x09,0x19,0x29,0x46}, {0x26,0x49,0x49,0x49,0x32},
    {0x01,0x01,0x7f,0x01,0x01}, {0x3f,0x40,0x40,0x40,0x3f},
    {0x1f,0x20,0x40,0x20,0x1f}, {0x3f,0x40,0x38,0x40,0x3f},
    {0x63,0x14,0x08,0x14,0x63}, {0x07,0x08,0x70,0x08,0x07},
    {0x61,0x51,0x49,0x45,0x43}, {0x00,0x7f,0x41,0x41,0x00},
    {0x02,0x04,0x08,0x10,0x20}, {0x00,0x41,0x41,0x7f,0x00},
    {0x04,0x02,0x01,0x02,0x04}, {0x80,0x80,0x80,0x80,0x80},
    {0x00,0x03,0x05,0x00,0x00}, {0x20,0x54,0x54,0x54,0x78},
    {0x7f,0x48,0x44,0x44,0x38}, {0x38,0x44,0x44,0x44,0x20},
    {0x38,0x44,0x44,0x48,0x7f}, {0x38,0x54,0x54,0x54,0x18},
    {0x08,0x7e,0x09,0x01,0x02}, {0x0c,0x52,0x52,0x52,0x3e},
    {0x7f,0x08,0x04,0x04,0x78}, {0x00,0x44,0x7d,0x40,0x00},
    {0x20,0x40,0x44,0x3d,0x00}, {0x7f,0x10,0x28,0x44,0x00},
    {0x00,0x41,0x7f,0x40,0x00}, {0x7c,0x04,0x18,0x04,0x78},
    {0x7c,0x08,0x04,0x04,0x78}, {0x38,0x44,0x44,0x44,0x38},
    {0x7c,0x14,0x14,0x14,0x08}, {0x08,0x14,0x14,0x18,0x7c},
    {0x7c,0x08,0x04,0x04,0x08}, {0x48,0x54,0x54,0x54,0x20},
    {0x04,0x3f,0x44,0x40,0x20}, {0x3c,0x40,0x40,0x20,0x7c},
    {0x1c,0x20,0x40,0x20,0x1c}, {0x3c,0x40,0x30,0x40,0x3c},
    {0x44,0x28,0x10,0x28,0x44}, {0x0c,0x50,0x50,0x50,0x3c},
    {0x44,0x64,0x54,0x4c,0x44}, {0x00,0x08,0x36,0x41,0x00},
    {0x00,0x00,0x7f,0x00,0x00}, {0x00,0x41,0x36,0x08,0x00},
    {0x08,0x08,0x2a,0x1c,0x08}
};

static void oled_cmd(uint8_t c) {
    uint8_t buf[2] = {0x00, c};
    i2c_ll_write(oled_i2c, OLED_I2C_ADDR, buf, 2);
}

static void oled_data(const uint8_t *data, size_t len) {
    // Chunk to avoid large stack
    uint8_t buf[17];
    buf[0] = 0x40;
    while (len > 0) {
        size_t n = (len > 16) ? 16 : len;
        memcpy(&buf[1], data, n);
        i2c_ll_write(oled_i2c, OLED_I2C_ADDR, buf, n + 1);
        data += n;
        len -= n;
    }
}

void oled_init(void) {
    i2c_ll_init(oled_i2c, I2C0_SDA_GPIO, I2C0_SCL_GPIO, I2C_BAUD_HZ);
    sleep_ms(50);

    oled_cmd(0xAE); // display off
    oled_cmd(0x20); oled_cmd(0x00); // horizontal addressing
    oled_cmd(0xB0); // page 0
    oled_cmd(0xC8); // COM scan dec
    oled_cmd(0x00); // low col
    oled_cmd(0x10); // high col
    oled_cmd(0x40); // start line
    oled_cmd(0x81); oled_cmd(0x7F); // contrast
    oled_cmd(0xA1); // segment remap
    oled_cmd(0xA6); // normal display
    oled_cmd(0xA8); oled_cmd(0x3F); // multiplex
    oled_cmd(0xA4); // display follows RAM
    oled_cmd(0xD3); oled_cmd(0x00); // display offset
    oled_cmd(0xD5); oled_cmd(0x80); // clock div
    oled_cmd(0xD9); oled_cmd(0xF1); // pre-charge
    oled_cmd(0xDA); oled_cmd(0x12); // com pins
    oled_cmd(0xDB); oled_cmd(0x40); // vcomh
    oled_cmd(0x8D); oled_cmd(0x14); // charge pump
    oled_cmd(0xAF); // display on

    oled_clear();
    oled_flush();
}

void oled_clear(void) {
    memset(g_buf, 0, sizeof(g_buf));
}

static void oled_set_pixel(uint8_t x, uint8_t y, bool on) {
    if (x >= OLED_W || y >= OLED_H) return;
    uint16_t idx = x + (y / 8u) * OLED_W;
    uint8_t mask = (1u << (y & 7u));
    if (on) g_buf[idx] |= mask;
    else g_buf[idx] &= (uint8_t)~mask;
}

void oled_draw_text(uint8_t x, uint8_t y, const char *text) {
    while (*text) {
        char c = *text++;
        if (c < 32 || c > 126) c = '?';
        const uint8_t *glyph = font5x7[(uint8_t)c - 32u];
        for (uint8_t col = 0; col < 5; ++col) {
            uint8_t line = glyph[col];
            for (uint8_t row = 0; row < 7; ++row) {
                oled_set_pixel((uint8_t)(x + col), (uint8_t)(y + row), (line >> row) & 0x01);
            }
        }
        x += 6;
        if (x + 5 >= OLED_W) { x = 0; y += 8; }
        if (y + 7 >= OLED_H) break;
    }
}

void oled_flush(void) {
    for (uint8_t page = 0; page < (OLED_H / 8u); ++page) {
        oled_cmd(0xB0 | page);
        oled_cmd(0x00);
        oled_cmd(0x10);
        oled_data(&g_buf[page * OLED_W], OLED_W);
    }
}

void oled_show_basic(const telem_t *t) {
    char line[24];
    oled_clear();
    snprintf(line, sizeof(line), "T:%.1fC RH:%.1f%%", t->env.temp_c, t->env.rh_pct);
    oled_draw_text(0, 0, line);
    snprintf(line, sizeof(line), "MQ135:%.0fppm %s", t->mq135_ppm,
             (t->mq135_state == AQ_DANG) ? "D" : (t->mq135_state == AQ_WARN ? "W" : "OK"));
    oled_draw_text(0, 16, line);
    snprintf(line, sizeof(line), "MQ7:%.0fppm %s H:%d", t->mq7_ppm,
             (t->mq7_state == AQ_DANG) ? "D" : (t->mq7_state == AQ_WARN ? "W" : "OK"),
             (int)t->mq7_heater_on);
    oled_draw_text(0, 32, line);
    oled_flush();
}
